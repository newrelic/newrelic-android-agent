
/*
 * Copyright (c) 2022 - present. New Relic Corporation. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

import com.android.builder.core.BuilderConstants
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
    id("com.github.johnrengelman.shadow")
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

apply from: "$project.rootDir/jacoco.gradle"

version = project.versions.agent
archivesBaseName = "android-agent"

tasks.withType(JavaExec).configureEach {
    if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_17)) {
        jvmArgs(["--add-opens=java.base/java.lang=ALL-UNNAMED",
                 "--add-opens=java.base/java.util=ALL-UNNAMED"])
    }
}

sourceSets {
    main.java.srcDirs += 'src/main/kotlin'
    main.resources.srcDirs += 'src/main/kotlin'

}

android {
    namespace "com.newrelic.agent.android"
    compileSdkVersion project.versions.agp.compileSdk

    defaultConfig {
        minSdkVersion project.versions.agp.minSdk
        targetSdkVersion project.versions.agp.targetSdk
    }
    buildFeatures { // Enables Jetpack Compose for this module
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion versions.composeCompiler
    }


    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            consumerProguardFiles 'proguard-rules.pro'
        }
    }

    // only interested in the release variant
    variantFilter { variant ->
        if (variant.buildType.name != BuilderConstants.RELEASE) {
            variant.ignore = true
        }
    }

    lintOptions {
        abortOnError true
        disable 'InvalidPackage', 'GradleDynamicVersion'
    }

    testOptions {
        unitTests {
            includeAndroidResources = true
            returnDefaultValues = true
            all {
                forkEvery = 1
                jacoco {
                    includeNoLocationClasses = true
                    excludes = ['jdk.internal.*']
                }
            }
        }
    }
    libraryVariants.all { variant ->
        logger.info("[FAT-JAR] Variant[${variant.name}]")
        variant.ext.fatJarProvider = toFatJarTask(variant)
        artifacts {
            // The artifact is a fat jar
            archives variant.ext.fatJarProvider
        }

        //Task To delete the default classes.jar from the AAR

        def deleteClassesJar = tasks.register("deleteClassesJar${variant.name.capitalize()}", Delete) {
            group = "build"
            description = "Deletes the default classes.jar from the AAR for ${variant.name}."
            dependsOn("sync${variant.name.capitalize()}LibJars")
            delete("$buildDir/intermediates/aar_main_jar/${variant.name}/classes.jar")
        }
        // Task to copy the fat JAR to aar_libs_directory.
        def copyFatJarToAarLibs = tasks.register("copyFatJarToAarLibs${variant.name.capitalize()}", Copy) {
            group = "build"
            description = "Copies the fat JAR to the aar_libs_directory for ${variant.name}."
            dependsOn("deleteClassesJar${variant.name.capitalize()}") // Make sure the fat JAR is built first
            from(variant.ext.fatJarProvider) // Take the fat JAR as the source
            into("$buildDir/intermediates/aar_main_jar/${variant.name}") // Destination
            rename {
                "classes.jar"
            }
        }
        // Run the copy task before packaging the library.
        variant.packageLibraryProvider.configure {
            dependsOn(copyFatJarToAarLibs)
        }
    }
}


dependencies {
    implementation "androidx.datastore:datastore-preferences:1.1.7"
    // Kotlin Standard Library (essential for Kotlin code)
    implementation("org.jetbrains.kotlin:kotlin-stdlib:${versions.java.kotlin}")
    // Kotlin Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
    // For bridging Kotlin Coroutines to Java CompletableFuture
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.7.3")

    implementation project(path: ':agent-core', configuration: 'fat')
    implementation( 'com.squareup.curtains:curtains:1.2.5')
    implementation("org.jetbrains.kotlin:kotlin-stdlib:${versions.java.kotlin}")

    compileOnly fileTree(dir: 'libs', include: '*.jar')
    compileOnly newrelic.deps.ndk

    compileOnly "androidx.navigation:navigation-compose:${project.versions.jetpack}"
    compileOnly "androidx.compose.ui:ui:${project.versions.composeui}"

    // Add Compose runtime for tests to satisfy the Compose Compiler
    testImplementation "androidx.compose.runtime:runtime:${project.versions.composeui}"
    testImplementation "androidx.compose.ui:ui:${project.versions.composeui}"

    testImplementation project(path: ':agent-core', configuration: 'fat')
    testImplementation fileTree(dir: 'libs', include: '*.jar')
    testImplementation newrelic.deps.ndk

    testImplementation 'org.robolectric:robolectric:' + project.versions.test.robolectric
    testImplementation 'junit:junit:' + project.versions.test.junit
    testImplementation 'org.mockito:mockito-core:' + project.versions.test.mockitoCore
    testImplementation 'androidx.test:core:' + project.versions.test.androidxCore
    testImplementation 'org.jetbrains.kotlin:kotlin-test-junit:' + project.versions.java.kotlin
}

/**
 * Finalize android-agent.jar for the passed variant
 */

def toFatJarTask(def variant) {
    def unshadedJarProvider = project.tasks.register("unshadedJar${variant.name.capitalize()}", Jar) {
        dependsOn variant.runtimeConfiguration
        dependsOn variant.getJavaCompileProvider()
        // Add dependency on Kotlin compilation if available
        if (project.hasProperty('kotlin')) {
            dependsOn "compile${variant.name.capitalize()}Kotlin"
        }
        archiveClassifier = "u"
        include("**/GsonInstrumentation*")
        from variant.getJavaCompileProvider().get().destinationDir
        // Include Kotlin compiled classes
        if (project.hasProperty('kotlin')) {
            from "$buildDir/tmp/kotlin-classes/${variant.name}"
        }
        from {
            variant.runtimeConfiguration.collect { it.isDirectory() ? it : zipTree(it) }
        }
    }

    def shadedJarProvider = project.tasks.register("shadedJar${variant.name.capitalize()}", ShadowJar) {
        dependsOn variant.runtimeConfiguration
        dependsOn variant.getJavaCompileProvider()
        // Add dependency on Kotlin compilation if available
        if (project.hasProperty('kotlin')) {
            dependsOn "compile${variant.name.capitalize()}Kotlin"
        }
        archiveClassifier = "s"
        from variant.getJavaCompileProvider().get().destinationDir
        // Include Kotlin compiled classes
        if (project.hasProperty('kotlin')) {
            from "$buildDir/tmp/kotlin-classes/${variant.name}"
        }
        from {
            variant.runtimeConfiguration.collect { it.isDirectory() ? it : zipTree(it) }
        }
        exclude '**/META-INF/**'
        exclude(unshadedJarProvider.get().includes)
        relocate("com.google.gson", "com.newrelic.com.google.gson") {
            // FIXME: Shadow does not exclude! This breaks Gson instrumentation.
            //  It's why we have to merge an unshaded and shaded jar below
            exclude("com.newrelic.agent.android.instrumentation.GsonInstrumentation")
        }
        relocate("com.google.flatbuffers", "com.newrelic.com.google.flatbuffers")
        mergeServiceFiles()
    }

    def fatJarProvider = project.tasks.register("fatJar${variant.name.capitalize()}", Jar) {
        dependsOn unshadedJarProvider
        dependsOn shadedJarProvider
        archiveClassifier = ""
        includeEmptyDirs = false
        manifest {
            attributes(
                    "Implementation-Vendor": "New Relic Inc.",
                    "Implementation-Title": "Android Agent",
                    "Implementation-Version": project.version,
                    "Built-Date": project.buildDate,
            )
            metaInf {
                from variant.mergedFlavor.consumerProguardFiles
                into "proguard"
            }
        }
        exclude '**/META-INF/**'
        exclude '**/module-info.class'
        exclude 'AndroidManifest.xml'
        exclude 'curtains/**'
        exclude 'kotlin/**'
        exclude 'org/**'
        exclude 'android/**'
        exclude 'AndroidManifest.xml'
        exclude 'kotlinx/**'
        exclude 'org/**'
        exclude '_COROUTINE/**'
        exclude 'android/**'
        exclude 'androidx/**'
        exclude 'jni/**'
        exclude 'okio/**'
        exclude 'DebugProbesKt.bin'
        exclude 'public.txt'
        exclude 'proguard.txt'
        exclude 'R.txt'
        duplicatesStrategy = DuplicatesStrategy.INHERIT
        from unshadedJarProvider.get().outputs.files.collect { it.isDirectory() ? it : zipTree(it) }
        from shadedJarProvider.get().outputs.files.collect { it.isDirectory() ? it : zipTree(it) }
    }

    fatJarProvider
}

/**
 * Configure artifact publishing
 */
apply from: "${rootDir}/gradle/publishing_aar.gradle"

publishing {
    publications {
        libraryProject(MavenPublication) {
            setGroupId 'com.newrelic.agent.android'
            setArtifactId monoEnabled ? 'android-agent-static' : 'android-agent'
            version rootProject.version
            artifact("$buildDir/outputs/aar/android-agent-release.aar") {
                builtBy assemble
            }

            pom {
                groupId = 'com.newrelic.agent.android'
                artifactId = monoEnabled ? 'android-agent-static' : 'android-agent'
                version = rootProject.version
                name = 'New Relic Android Agent'
                description = 'The New Relic Android agent provides performance monitoring instrumentation for Android applications'
            }
        }
    }
}
